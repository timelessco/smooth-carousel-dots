"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @since 2016-11-23 10:23
 * @author vivaxy
 */
const chalk = require("chalk");
const log = require("log-util");
const wrap = require("word-wrap");
const prompts = require("prompts");
const external_editor_1 = require("external-editor");
const history_1 = require("./messages/history");
const commit_types_1 = require("./messages/commit-types");
const gitmojis_1 = require("./messages/gitmojis");
const commitlint_config_1 = require("./messages/commitlint-config");
function debug(...message) {
    log.debug('gacp:prompt', ...message);
}
function trim(input) {
    return input.trim();
}
async function prompt({ editor, emojiType, }) {
    const [typeList, gitmojiList] = await Promise.all([
        commit_types_1.getCommitTypes(),
        gitmojis_1.getGitmojis({ emojiType }),
    ]);
    const history = history_1.getHistory();
    function findInitial(list, key) {
        const index = list.findIndex(function ({ value }) {
            return value === key;
        });
        if (index === -1) {
            return 0;
        }
        return index;
    }
    function suggest(input, choices) {
        if (!input) {
            return choices;
        }
        return choices.filter(function ({ title, value }) {
            return (title.toLowerCase().indexOf(input.toLowerCase()) > -1 ||
                value.toLowerCase().indexOf(input.toLowerCase()) > -1);
        });
    }
    debug('history:', history);
    // ${type}(${scope}): ${emoji}${subject} \n\n ${body} \n\n ${footer}
    const questions = [
        {
            type: 'autocomplete',
            name: 'type',
            message: "Select the type of change that you're committing",
            choices: typeList,
            initial: findInitial(typeList, history.type),
            suggest,
            format: trim,
        },
        {
            type: 'text',
            name: 'scope',
            message: 'Denote the scope of this change',
            initial: history.scope,
            format: trim,
        },
        {
            type: 'autocomplete',
            name: 'gitmoji',
            message: 'Choose a gitmoji',
            choices: gitmojiList,
            initial: findInitial(gitmojiList, history.gitmoji),
            suggest,
            format(input) {
                if (input === 'none') {
                    return '';
                }
                return trim(input);
            },
        },
        {
            type: 'text',
            name: 'subject',
            message: 'Write a short, imperative tense description of the change',
            initial: history.subject,
            format: trim,
        },
        {
            type: 'text',
            name: 'body',
            message: 'Provide a longer description of the change',
            initial: history.body,
            format: trim,
        },
        {
            type: 'text',
            name: 'footer',
            message: 'List any breaking changes or issues closed by this change',
            initial: history.footer,
            format: trim,
        },
    ];
    const answers = history_1.DEFAULT_MESSAGES;
    for (const q of questions) {
        let answer = {};
        if (editor && q.name === 'body') {
            const body = trim(external_editor_1.edit(history.body));
            answer = {
                body,
            };
            log.success(chalk.bold(q.message), chalk.grey('â€¦'), body);
        }
        else {
            answer = await prompts(q, {
                onCancel() {
                    process.exit(0);
                },
            });
        }
        debug('got answer', answer);
        Object.assign(answers, answer);
    }
    debug('got answers', answers);
    history_1.setHistory(answers);
    const { 'header-max-length': headerMaxLengthRule, 'body-max-line-length': bodyMaxLengthRule, 'footer-max-line-length': footerMaxLengthRule, } = await commitlint_config_1.getCommitlintConfigRules();
    const maxHeaderLength = commitlint_config_1.getRuleValue(headerMaxLengthRule, Infinity);
    debug('maxHeaderLength', maxHeaderLength);
    // parentheses are only needed when a scope is present
    const scope = answers.scope ? `(${answers.scope})` : '';
    const gitmoji = answers.gitmoji ? `${answers.gitmoji} ` : '';
    // Hard limit this line
    let head = `${answers.type}${scope}: ${gitmoji} ${answers.subject}`;
    head = head.slice(0, maxHeaderLength);
    // Wrap these lines
    function getWrapOptions(width) {
        return {
            trim: true,
            newline: '\n',
            indent: '',
            width,
        };
    }
    function wrapWords(words, rule) {
        const maxLineWidth = commitlint_config_1.getRuleValue(rule, words.length);
        return wrap(words, getWrapOptions(maxLineWidth));
    }
    const body = wrapWords(answers.body, bodyMaxLengthRule);
    const footer = wrapWords(answers.footer, footerMaxLengthRule);
    await commit_types_1.updateTypesStat(answers.type);
    await gitmojis_1.updateGitmojisStat({ key: emojiType, value: answers.gitmoji });
    let res = head;
    if (body) {
        res += `\n\n${body}`;
    }
    if (footer) {
        res += `\n\n${footer}`;
    }
    return res;
}
exports.default = prompt;
